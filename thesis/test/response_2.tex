% LaTeX rebuttal letter example. 
% 
% Copyright 2019 Friedemann Zenke, fzenke.net

\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{lipsum} % to generate some filler text
\usepackage{fullpage}

\usepackage{xifthen}
\newcounter{reviewer}
\setcounter{reviewer}{0}
\newcounter{point}[reviewer]
\setcounter{point}{0}
\newcounter{subpoint}[reviewer]
\setcounter{subpoint}{0}

% command declarations for reviewer points and our responses
\newcommand{\reviewersection}{\stepcounter{reviewer} \bigskip \hrule
                  \section*{Reviewer \thereviewer}}

\newenvironment{point}
   {\refstepcounter{point} \bigskip \noindent {Point \textbf{\arabic{point}} -- } \ }
   {\par }

\newenvironment{subpoint}
   {\refstepcounter{subpoint} \bigskip \noindent {Point \textbf{\arabic{point}.\arabic{subpoint}} -- } \ }
   {\par }

\newenvironment{action}
   {\medskip \noindent \begin{sf}\textbf{Action}:\ }
   {\medskip \end{sf}}

\newenvironment{reply}
   {\medskip \noindent \begin{sf}\textbf{Reply}:\ }
   {\medskip \end{sf}}


\begin{document}

\section*{Response to the reviewers}
% General intro text goes here
We thank the reviewers for their critical assessment of our work. 
In the following we address their concerns point by point. 

% Let's start point-by-point with Reviewer 1
\reviewersection
The paper presents an analytical model of energy consumption by an application running on a multicore processor. The parameters of the model are the frequency, the number of active cores, and the problem size. The model is experimentally validated for several applications on a computer node equipped with two Xeon Phi E5-2698 16-core processors.
The submission has a potential for publication. However, the following reservations do not allow me to recommend it for publication in the current form:

% Point one description 
\begin{point}
\end{point}

\begin{subpoint}
The main difference of the presented model from other frequency-based models is the inclusion of the workload in the model (inclusion of the number of active cores is a minor difference, hardly worth of publication). However, this main contribution is practically not studied. The corresponding parameter N is neither motivated nor explained. It is not clear how to determine N for your application.
\end{subpoint}

\begin{reply}
%The main difference between the model presented model and other frequencies based on frequency is the inclusion of the workload (the number of active cores, we agree that makes a small difference, hardly worthy of being published). However, this main contribution, besides considering all parameters, is hardly available.
Besides the inclusion of the workload that can be considered the main contribution (the number of active cores, we agree that makes a small difference, hardly worthy of being published). The inclusion of all parameters is hardly available in fact we couldn't find any that considered all.

%We understand that the workload must be defined in a manner making possible to quantify N for all applications uniformly.  For that, we clarified the discussion about the input size in several parts of the paper, by providing a definition from our point of view (other variants are still possible, for instance when considering counting memory access operations). In section IV.B a general definition of input size was provided:
We clarified the input size in several parts of the paper by defining our perspective (other variants are still possible, for instance, when considering counting memory access operations). In section IV.B, a general definition of input size was provided:
"Finally, to fully characterize the application, a parameter representing the application's workload, called input size $N$, is introduced, representing the number of basic operations need to complete a problem \cite{Kumar1994AnalyzingArchitectures}"

\end{reply}


\begin{subpoint}
In the experimental subsection V.C, the authors say that for any application in their experiments they vary N from 1 to 5. What does it mean? What may that mean, for example, for matrix multiplication or an FFT if I want to use their model? Moreover, as N is the major new parameter, the proposed model should be compared with other energy models using workload as a model parameter, both theoretically and experimentally (for example, Shahid, Arsalan, et al. "A comparative study of techniques for energy predictive modelling using performance monitoring counters on modern multicore cpus." IEEE Access (2020)).
\end{subpoint}

\begin{reply}
The N parameter is a measure of the problem's size, defined as the number of basic operations to complete a task \cite{Kumar1994AnalyzingArchitectures}. We can say that the basics operations are the CPU instructions. Because of some CPU architecture characteristics as the pipeline, the instructions are executed approximately the same average time. Thus, it is possible to estimate the problem size by looking at the execution time, allowing us to divide a large problem size into several smaller ones as done in the work of Oliveira \cite{Oliveira2018ApplicationCores}.

The unit of measurement should accompany the definition. However, for simplicity, we assigned numbers from 1 the smallest size to 5 the largest, increasing the problem linearly, allowing us to interpolate any input in between these values.

Mapping the application input to problem size can be accomplished in many different ways. For instance, we could create a function to map one to another or use an correlation of some system event to estimate the problem size, but this is another major topic and cannot be covered in this journal.

We thank the author for the reference, but our journal focuses on the inclusion of all parameters as mentioned previously. Thus we do not go deep into each of the models since they are already validated in previous work.

We included this explanation of the input size division in section V.C:
"For the input size, by assuming that all CPU instructions are executed at approximately the same average time, the number of basic operations will be directly correlated with the time. Thus, we can estimate the problem size by looking at the execution time, allowing us to divide a large problem size into several smaller ones knowing their relationship as done in the work of Oliveira \cite{Oliveira2018ApplicationCores}.
The unit of measurement should accompany the definition. However, for simplicity, we assigned numbers from 1 the smallest size to 10 the largest, increasing the problem linearly, that way allow us also to interpolate any input in between these values."
\end{reply}

\begin{subpoint}
The authors do need to compare the accuracy of their model to the accuracy of the state-of-the-art models. They can set p to 32, fix the frequency, f, and build their model and other models, accounting for the workload size, for a wide range of workload sizes, and compare their accuracy. In the submitted paper, there is no single graph where the problem size would be a variable.
\end{subpoint}

\begin{reply}
To complement the results as requested by the reviewer, we also added figures in section V.D showing the model fitting regarding the input size.
\end{reply}


\begin{point}
The experimental part is rather poor lacking many important details. Most importantly, it is not clear how the energy consumption is measured. Without detailed description of the methodology, I cannot trust the experimental results or reproduce them.
\end{point}

\begin{reply}
The experiments related to power and energy consumption using traditional measures served to validate by correlation the samples collected using IPMI before its adoption (see previous works). Nevertheless, as requested, we complement the explanation in section V.C:
"For each configuration, samples were collected using IPMI every 1 second. This sampling rate was chosen because the order of magnitude of the applications' mean run time was minutes. Therefore, this rate provides enough samples to measure average power. Additionally, timestamps and the total run time were collected. The total energy spent on each configuration is estimated by first interpolating the power samples using the first-order method, and then integrating this function over time."
\end{reply}

\begin{point}
 The authorsâ€™ criticism of the performance counters as model parameters is shallow and does not reflect the state of the art. There are recent comprehensive studies on this subject, which they are unaware of (for example, Fahad, Muhammad, et al. "A comparative study of methods for measurement of energy of computing." Energies 12.11 (2019): 2204).
\end{point}

\begin{reply}
We thank the author for the reference, which we use as an example in the revised text. However, our criticisms about performance counters still holds. In fact we can find the same opinion in many other journal papers as in \cite{Weaver2008, Weaver2013a, Das2019SoK:Security, McGuire2009, Ramos2019AnCounters}. Some of the main points are the following:

%All architectures do not equally support performance counters and their accuracy varies with their number too. Regarding accuracy, that is not a real problem as the measurements can be used in a comparative manner instead of an absolute one
All architectures do not equally support performance counters and their accuracy varies with their number too. Indeed, many models are based on performance counters that do not need to rely on the counter's precise data to provide useful energy prediction. However, generally, they are specific for an architecture of a set of architectures, yet this implies other limitations. The number of counters that we can read simultaneously (generally limited to 5 in hardware) leads to another problem of finding a subset of the counters \cite{Silva-De-Souza2020Containergy-aWorkloads}. Also, claiming the system counters to our driver making no other application would be able to use neither the user for debugging.

That said, our final goal is to provide a generic driver capable of running on most Linux devices, and for that, we believe using performance counters is not the right way to go, at least for now while PMUs are not reliable and standardized. For those reasons, we preferred to use a more generic method, already validated in our previous work \cite{Silva2018Energy-optimalApplications}.
\end{reply}

\bibliographystyle{unsrt}
\bibliography{references.bib}

\end{document}