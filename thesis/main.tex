\documentclass[
papersize=a4,
pagelayout=default,
fontname=latinmodern,
fontsize=11pt,
twoside,
final,
faculty=fpms,
]{umons-Thesis}

% Styles
\headstyles{umons}
\pagestyle{umons}
%\setcounter{secnumdepth}{4}

\usepackage{breakcites}
\usepackage[main=english]{babel}
\usepackage[autostyle=true]{csquotes}
\usepackage[babel=true]{microtype}
\usepackage{float}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{mathtools}
\usepackage{siunitx}
\usepackage{multirow}

\sisetup{%
	binary-units = true,%	loads units for binary data (\bit, \byte)
}
\usepackage[%
hidelinks,%				hides links (removing color and border)
pdfusetitle,%			uses the content of \author{}... for metadata
pdfdisplaydoctitle,%	displays document title instead of file name in title bar
]{hyperref}
\usepackage[capitalise]{cleveref}
\usepackage{outlines}
\usepackage{listings}


\definecolor{light-gray}{gray}{1}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{gray}{1}
\definecolor{commentgreen}{RGB}{2,112,10}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}


\lstdefinestyle{jsonstyle}{
	commentstyle=\color{commentgreen},
	backgroundcolor=\color{light-gray},
	basicstyle=\ttfamily\small,
	breakatwhitespace=false, 
	breaklines=true, 
	captionpos=b, 
	keepspaces=true, 
	numbers=left, 
	numbersep=5pt, 
	showspaces=false, 
	showstringspaces=false,
	showtabs=false, 
	tabsize=1,
	literate={\ \ }{{\ }}1
}

\lstdefinelanguage{json}{
	basicstyle=\ttfamily\small\normalfont,
	numbers=left,
	numberstyle=\scriptsize,
	stepnumber=1,
	numbersep=4pt,
	showstringspaces=false,
	breaklines=true,
	frame=lines,
	tabsize=1,
	literate={\ \ }{{\ }}1,
	backgroundcolor=\color{background},
	morecomment=[f][\color{red}][0]{*},
	literate=
	{:}{{{\color{punct}{:}}}}{1}
	{,}{{{\color{punct}{,}}}}{1}
	{\{}{{{\color{delim}{\{}}}}{1}
	{\}}{{{\color{delim}{\}}}}}{1}
	{[}{{{\color{delim}{[}}}}{1}
	{]}{{{\color{delim}{]}}}}{1},
}

\lstdefinestyle{ccodestyle}{
	language=C,
	commentstyle=\color{commentgreen},
	backgroundcolor=\color{light-gray},
	basicstyle=\ttfamily\small,
	breakatwhitespace=false, 
	breaklines=true, 
	captionpos=b, 
	keepspaces=true, 
	numbers=left, 
	numbersep=5pt, 
	showspaces=false, 
	showstringspaces=false,
	showtabs=false, 
	tabsize=2,
	xleftmargin=0.5cm,
	emph={int,char,double,float,unsigned,return},
	emphstyle={\color{blue}}
}

\lstdefinestyle{pythonStyle}{
	%backgroundcolor=\color{backcolour},
	backgroundcolor=\color{light-gray},
	basicstyle=\ttfamily\small,
	commentstyle=\color{codegreen}\itshape,
	keywordstyle=\color{magenta}\bfseries,
	%numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	belowcaptionskip=\medskipamount,
	breakatwhitespace=false, 
	breaklines=true, 
	captionpos=t, 
	keepspaces=true,
	frame=top,frame=bottom,
	framexbottommargin=5pt,
	%framextopmargin=5pt,
	xleftmargin=0.5cm,
	numbers=left, 
	numbersep=5pt, 
	showspaces=false, 
	showstringspaces=false,
	showtabs=false, 
	tabsize=2
}


\lstset { %
	language=C++,
	backgroundcolor=\color{black!5}, % set backgroundcolor
	basicstyle=\footnotesize,% basic font setting
}

\newcommand*\rot{\rotatebox{90}}
\def\BibTeX{{\rmfamily B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
		T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\DeclareOldFontCommand{\rm}{\normalfont\rmfamily}{\mathrm}
\DeclareOldFontCommand{\sf}{\normalfont\sffamily}{\mathsf}
\DeclareOldFontCommand{\tt}{\normalfont\ttfamily}{\mathtt}
\DeclareOldFontCommand{\bf}{\normalfont\bfseries}{\mathbf}
\DeclareOldFontCommand{\it}{\normalfont\itshape}{\mathit}
\DeclareOldFontCommand{\sl}{\normalfont\slshape}{\@nomath\sl}
\DeclareOldFontCommand{\sc}{\normalfont\scshape}{\@nomath\sc}

\crefname{lstlisting}{listing}{listings}
%%        %%
% DOCUMENT %
% ======== %


% Metadata
% --------

\author{Vitor \textsc{Ramos Gomes da Silva}}

\date{\today}

\title{Energy-optimal configurations for high-performance computing applications: automated low-impact characterization and performance optimization of shared-memory applications}
%\title{My very long two-line PhD thesis title}
%\title{My supra long PhD thesis title just to verify that nothing is broken because of a long title}

\committeeMembers{%
	Prof. Carlos Alberto \textsc{VALDERRAMA}, Supervisor\\
	Prof. Pierre \textsc{MANEBACK}, Co-supervisor\\
	Prof. Thierry \textsc{DUTOIT}, Chair\\
	Prof. Sidi \textsc{MAHMOUDI}, Chair\\
	Prof. Samuel \textsc{XAVIER-DE-SOUZA}, Chair 
}



% Text
% ----

\begin{document}
	
	\umonsThesisTitlePage
	
	\frontmatter
	
	\begin{umonsThesisAbstract}
		Energy consumption is a key to enabling exascale High performance Computing (HPC). However, energy-optimized hardware and software combinations could still be inefficient if the software operates poorly. 
		
		Software operation relies on dynamic scaling of frequency and voltage (DVFS) and dynamic power management (DPM), but none have priority information on the application, leading to inefficient software operation. 
		
		This work proposes a set of tools, models, and algorithms for energy optimization aimed at high-performance computing based on knowledge of the application and the specific architecture. The main contributions of this work are:
		
		A framework called PascalSuite automatically measures and compares multiple executions of a parallel application according to various scenarios characterized by input arrangements, number of threads, number of cores, and frequencies. As a result, PascalSuite can automate designing application models with an overhead of less than 1\%.
		
		A full-system energy model based on the CPU frequency and the number of cores. The model aims to understand and optimize the energy behavior of parallel applications in HPC systems according to application parameters, such as the degree of parallelism and CPU parameters related to dynamic and static power.
		
		A methodology that combines measurement data with a heuristic algorithm to provide insights into choosing the best phase divisions. Our heuristic can reduce the scan space from $10^{7000}$ to $10^2$ with an average error of 10\% and up to 38\% reduction in energy consumption using optimal distribution compared to standard Linux DVFS.
		A novel normalised time representation of the application serving to characterize the application parameters and model, named application finger print. 
	\end{umonsThesisAbstract}
	
	% \vspace{2cm}
	% \textbf{Keywords :} Energy Model; Dynamic Frequency and Voltage Scaling; Dynamic Power Management; High Performance Computing
	
	\tableofcontents*
	\listoffigures*
	\listoftables*
	
	
	\mainmatter
	
	\chapter{Introduction} \label{chapter:introduction}
	In this chapter, we present the motivations for this work, as well as its objectives and main contributions.
	\include{intro/intro}
	
	\chapter{Theoretical background} \label{chapter:theoretical_background}
	This chapter will give the reader a better understanding of some terms used throughout the thesis, as well as details of configurations, the chosen benchmarks, and the architecture of the case study.
	\include{experiments/setup}
	
	\chapter{Parallel Scalability Suite} \label{chapter:pascal_suite}
	High-performance computing systems have become increasingly dynamic, complex, and unpredictable. To help build software that uses full-system capabilities, performance measurement and analysis tools exploit extensive execution analysis focusing on single-run results. Despite being effective in identifying performance hotspots and bottlenecks, these tools are not sufficiently suitable to evaluate the overall scalability trends of parallel applications. Either they lack the support for combining data from multiple runs or collect excessive data, causing unnecessary overhead. 
	In this chapter, we present a tool for automatically measuring and comparing several executions of a parallel application according to various scenarios characterized by the input arrangements, the number of threads, number of cores, and frequencies.
	Unlike other existing performance analysis tools, the proposed work covers some gaps in specialized features necessary to better understand computational resources scalability trends across configurations.
	In order to improve scalability analysis and productivity over the vast spectrum of possible configurations, the proposed tool features automatic instrumentation, direct mapping of parallel regions, accuracy-preserving data reductions, and ease of use.
	As it aims at accurately understanding scalability trends of parallel applications, detailed single-run performance analyses show minimal intrusion (less than 1\% overhead).
	
	\include{pascalanalyzer/pascalanalyzer}
	\include{fingerprint/fingerprint}
	\include{framework/validation}
	
	\chapter{Application energy and performance models} \label{chapter:models}
	Energy consumption is crucial in high-performance computing (HPC), especially to enable the next exascale generation. Hence, modern systems implement various hardware and software features for power management. Nonetheless, due to numerous different implementations, we can always push the limits of software to achieve the most efficient use of our hardware. To be energy efficient, the software relies on dynamic voltage and frequency scaling (DVFS), as well as dynamic power management (DPM). Yet, none have privileged information on the hardware architecture and application behavior, which may lead to energy-inefficient software operation. 
	This chapter proposes analytical modeling for architecture and application behavior that can be used to estimate energy-optimal software configurations and provide knowledgeable hints to improve DVFS and DPM techniques for single-node HPC applications.
	Additionally, model parameters, such as the level of parallelism and dynamic power, provide insights into how the modeled application consumes energy, which can be helpful for energy-efficient software development and operation.
	This novel analytical model takes the number of active cores, the operating frequencies, and the input size as inputs to provide energy consumption estimation.
	In this chapter we present the modeling of 13 parallel applications employed to determine energy-optimal configurations for several different input sizes.
	The results show that up to 70\% of energy could be saved in the best scenario compared to the default Linux choice and 14\% on average.
	We also compare the proposed model with standard machine-learning modeling concerning training overhead and accuracy. The results show that our approach generates about 10 times less energy overhead for the same level of accuracy.
	\include{models/models}
	%\include{optmizers/optmizers}
	\include{optmization/optmization}
	
	\chapter{Application-phase heuristic energy optimization} \label{chapter:phases}
	Dynamic voltage and frequency scaling (DVFS) and dynamic power management (DPM) are essential techniques for saving energy in modern computers. These techniques control hardware resources such as frequency and number of active processors. Although there is much work on the subject, there is an underexplored sub-topic: the impact of the choice of phase division on energy consumption.
	This chapter analyzes the impact of phase division on the energy efficiency of algorithms and proposes a methodology that combines measurement data with a heuristic to provide insights into choosing the best phase divisions.
	Our heuristic can reduce the scan space from $10^{7000}$ to $10^2$ with an average error of 10\% and up to 38\% reduction in energy consumption using optimal distribution compared to standard Linux DVFS. Moreover, we evaluated the trade-off of having too many divisions and the overhead caused. Finally, we have identified that there is usually a limit to the number of phases a running application can benefit from, giving a lower limit to the minimum number of phases.
	\include{phases/phases}
	
	
	\chapter{Conclusions and future work} \label{chapter:conclusions}
	In this chapter, we deal with the conclusions about the effectiveness of the frameworks and the advantages and disadvantages of using models and algorithms with additional information on applications and architectures for energy optimization.
	We also discussed what could be improved in each approach and framework.
	\include{conclusion}
	
	%\bibliographystyle{plain}
	%\bibliography{references.bib}
	\include{references.tex}
	
	\backmatter
	
\end{document}