\section{Power Model} \label{sec:power_model}

The developed power model is based on the developed frequency models \cite{Rauber2014EnergyScaling, Goel2016AProcessors, Du2017ModelingSystems, Gonzalez1997SupplyCMOS}. In this approach, the idea is to reduce the complexity of the processor dynamics by looking only at the main element that it is composed of, the transistor. Thus, modeling the power consumption can be resumed to model the logic gates and multiply this by the total number of gates, reducing the complexity of the modeling process.

FINFET and MOSFET comprise the main techniques to manufacture transistors. However, FINFET is the more recent,  and has gradually replaced the mature technology MOSFET. Despite having different characteristics, they have aspects in common that can be modeled  \cite{Rauber2014EnergyScaling, Goel2016AProcessors, Du2017ModelingSystems, Gonzalez1997SupplyCMOS}. These are static power $P_{\rm static}$, dynamic power $P_{\rm dynamic}$, and leakage power $P_{\rm leak}$, which, in combination, comprise  and approximate the total power draw.

The dynamic power and leakage power behavior can be approximated by the following equations, respectively, as shown by Sarwar et al.~\cite{Sarwar1997CmosCalculation} and Butzen et al.~\cite{Butzen2007LeakageGates}.
\begin{equation}
	P_{dynamic}=CV^2f,
	\label{eq:power_dyn}
\end{equation}
\begin{equation}
	P_{leak} \underset{\sim}{\propto} V,
	\label{eq:power_leak}
\end{equation}
where $C$ is the load capacitance, $V$ is the voltage applied to the circuit, and $f$ is the switching frequency.

Another common approximation is to assume a linear relationship between the voltage and the applied frequency~\cite{Usman2013ANoC}, such that:
\begin{equation}
	f \underset{\sim}{\propto} V,
	\label{eq:f_v}
\end{equation}

These approximations have been demonstrated to be very precise. In the work of Silva et al., the mean percentage error was calculated to be 0.75\% \cite{Silva2019Energy-OptimalApplications}.

Thus, the proposed model for one processing core of a multi-core processor is derived by using Equations (10)--(12) to write \cref{eq:total_power}.
\begin{equation}
	P(f)= c_1f^3+c_2f+c_3,
	\label{eq:total_power}
\end{equation}
where $c_1$ $c_2$, and $c_3$ are the model's parameters associated with the dynamic, leakage and static power aspects, respectively. Including the number of active cores $p$, the proposed estimation of the power consumption of the whole processor becomes \cref{eq:power_final}
\begin{equation}
	P(f,p)= p(c_1f^3+c_2f)+c_3,
	\label{eq:power_final}
\end{equation}

\section{Performance Model} \label{sec:performance_model}
We consider a program as a set of instructions executed on a mean frequency $f$ with $c_k$ instructions per cycle to model the application execution time. The time $T_f$ that this program will take to complete at a given frequency is devised as follows:
\begin{equation}
	T_f=\frac{I}{c_kf},
	\label{eq:freqrel}
\end{equation}
where $I$ is the total number of instructions and $c_k$ the ratio of instructions per unit of time.

The next step is to include the number of cores in the equation. Amdahl's law~\cite{Amdahl1967ValidityCapabilities}, gives the theoretical background for that. It describes the speedup in latency of the execution of a task at a fixed workload.
\begin{equation}
	S=\frac{T_s}{T_p}=\frac{1}{1-w+\frac{w}{p}},
	\label{eq:amdahl}
\end{equation}
where $T_s$ is the serial time, $T_p$ the parallel time, $S$ is the theoretical speedup of the execution of the whole task, $w$ is the proportion of the execution time that benefits from improving system resources, and $p$ is the speedup part of the task that benefits from improved system resources. Combining this with \cref{eq:freqrel}, the parallel time at frequency $f$ can be written as:
\begin{equation}
	T_p=\frac{T_s}{S}=\frac{T_f}{\frac{1}{1-w+\frac{w}{p}}},
	\label{eq:parallel_time}
\end{equation}

We can then write the equation of the program execution time as a function of frequency, the number of cores, and parallelism  as \cref{eq:performance} and subsequently derive \cref{eq:performance_2}:
\begin{equation}
	T(f,p)=\frac{I}{ \frac{c_kf}{1-w+\frac{w}{p}} },
	\label{eq:performance}
\end{equation}
\begin{equation}
	T(f,p)=\frac{d_1(p-wp+w)}{fp},
	\label{eq:performance_2}
\end{equation}
where $d_1$ is a constant.

Finally, to fully characterize the application, a parameter representing the application's workload, called input size $N$, is introduced, representing the number of basic operations needed to complete a problem \cite{Kumar1994AnalyzingArchitectures}. In Oliveira et al. \cite{Oliveira2018ApplicationCharacterization}, they showed that this parameter could generally be described as exponential. Therefore the proposed performance model is presented in \cref{eq:performance_final}. This resulting equation describes the behavior of the execution time of a program for an input $N$, frequency $f$, and active cores $p$:
\begin{equation}
	T(f,p,N)=\frac{d_1N^{d_2}(p-wp+w)}{fp},
	\label{eq:performance_final}
\end{equation}
where $d_1$, $d_2$ and $w$ are constants that depend on the application.

\section{Energy Model} \label{sec:energy_model}
Combining the power model output described in~Section \ref{sec:power_model} and the characterization of the application performance described in Section \ref{sec:performance_model}, the total energy can be modeled as:
\begin{equation}
	E(f,p,N)=P(f,p)\times{\rm T}(f,p,N),
	\label{eq:en_combination}
\end{equation}
where $P(f,p)$ is the total power modeled by~\cref{eq:power_final}, ${T}(f,p,N)$ is the execution time estimated by the \cref{eq:performance_final}, $f$ is the frequency, $p$ is the number of active cores, and $N$ is the input size. The final equation can be written as:
\begin{equation}
	E(f,p,N)=\frac{d_1N^{d_2}(p-wp+w)(p(c_1f^3+c_2f)+c_3)}{fp}.
	\label{eq:en_final}
\end{equation}