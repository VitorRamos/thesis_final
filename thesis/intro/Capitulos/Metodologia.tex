% Capítulo 3
\chapter{Metodologia} \label{cap:metodologia}

\section{Configuração} \label{sec:config}
Nos experimentos realizados neste trabalho, foi utilizado um nó de computação que consiste em dois processadores Intel Xeon E5-2698 v3 com dezesseis núcleos e duas threads de hardware para cada núcleo. A frequência máxima não turbo de 2.3 GHz e a memória física total do nó é de 128 GB (8 $ \times $ 16 GB) com o sistema operacional CentOS 6.5 e kernel Linux  versão 4.16. A frequência turbo e o hyper-thread foram desativados durante todos os experimentos.


\section{Aplicações} \label{sec:apps}

O processo de caracterização foi realizado utilizando aplicações do PARSEC benchmark que possui uma suíte de aplicações paralelas que foi projetado para ser representativo da próxima geração de programas de memória compartilhada em chips com múltiplos processadores. As aplicações do PARSEC cobrem as mais diversas áreas, tais como, análise de finanças, visão computacional, mineração de dados, aprendizagem de máquina e processamento de mídia, variando no tipo de paralelização, intensidade de comunicação e tamanho do problema de entrada. Neste trabalho foram utilizadas as aplicações Blackscholes, Fuidanimate, Raytrace e Swaptions da versão 3.0.

\begin{itemize}
	
	\item Blackscholes: calcula os preços de uma carteira de opções européias analiticamente com a equação diferencial parcial de Black-Scholes. Não há expressão em forma fechada para a equação de Black-Scholes e, como tal, deve ser calculada numericamente. Suas entradas são número de threads, arquivo de entrada contendo os dados das opções e nome do arquivo de saída.
	
	\item Fuidanimate: usa uma extensão do método de hidrodinâmica de partículas suavizadas (SPH) para simular um fluido incompressível para fins de animação interativa. Suas entradas são o número de threads do número de quadros e um arquivo de entrada com informações de todas as partículas fluidas e suas propriedades.
	
	\item O Raytrace: uma versão do método de raytracing que normalmente seria empregada para animações em tempo real, como jogos de computador. Está otimizado para a velocidade e não para o realismo. A complexidade computacional do algoritmo depende da resolução da imagem de saída e da cena. As entradas usadas nesses aplicativos são o número de threads, o número de quadros, um objeto 3D e a resolução da tela.
	
	\item Swaptions: utiliza o framework Heath-Jarrow-Morton para calcular os preços do portifolio swaptions. Swaptions emprega simulações de Monte Carlo para computar os preços. A entrada para este programa é o número de threads, swaptions e tentativas. 
	
\end{itemize}

\section{Ajuste do modelo de potência} \label{sec:met_ajuste_pw}

Para encontrar as constantes, foram desenvolvidas aplicações que utilizam todo o tempo do processador com diversas instruções diferentes, pois, dependendo da instrução executada, pode variar o consumo do processador.

Com essas aplicações foram coletadas amostras de frequência com RAPL e IPMI durante sua execução, variando a frequência de 1.2 GHz até 2.3 GHz, com passos de 100 MHz, e o número de núcleos de 2 até 32, com um passo de 2. A taxa de amostragem foi de aproximadamente 1 segundo e o tempo de execução de 2 a 5 minutos. Entre cada teste foi esperado um tempo de 30 segundos para as próximas medições não serem afetadas pelas anteriores. Com esses dados foi feita uma regressão multi-linear com o método dos mínimos quadrados para descobrir os coeficientes da equação de potência descrito na Seção \ref{sec:potencia}. Que se resume a resolver a equação $\vec{c}=(A^TA)^{-1}A^TB$, onde $\vec{c}$ é o vetor dos coeficientes da equação $A\vec{c}=B$, onde:

\begin{equation}
A=
\begin{bmatrix}
p_1f_1^3 & p_1f_1 & 1 & s_1 \\
p_2f_2^3 & p_1f_2 & 1 & s_1 \\
& \vdots \\
p_nf_m^3 & p_nf_m & 1 & s_2 \\
\end{bmatrix}
\quad e\quad B= 
\begin{bmatrix}
P_1 \\
P_2 \\
\vdots \\
P_k
\end{bmatrix}
\end{equation}

Para cada valor de frequência $f_i$ e número de núcleos $p_i$ associados a potencia $P_i$.

Para validar este modelo foi calculado a média do erro percentual \abrv[MEP -- Média do erro percentual]{(MEP)} e o erro médio absoluto \abrv[MEA -- Média do erro absoluto]{(MEA)}. Essas métricas foram escolhida devido à diferença significativa entre o menor e maior valor. Elas são descritas por (\ref{eq:mpe}).

\begin{equation}
MEP=\frac{1}{n_{amostras}}\sum_{i}^{n_{amostras}}{\frac{|y_i-y_{\rm model}|}{y_i}} \quad MEA=\frac{1}{n_{amostras}}\sum_{i}^{n_{amostras}}{|y_i-y_{\rm model}|}
\label{eq:mpe}
\end{equation}


\section{Treinamento do modelo de performance} \label{sec:met_ajuste_perf}

Para caracterizar a aplicação, foram coletados o tempo de execução para diferentes configurações de números de núcleos ativos dentro do intervalo de $ 1 <= p <= 32 $, e frequência no intervalo de $ 1,2 <= f <= 2,2 $ GHz, com passos de 100 MHz para 5 tamanhos de entradas diferentes, que por sua vez foram escolhidos de forma a dobrar o tamanho do problema a cada entrada, seguindo a equação:

\begin{equation}
N(x)=\frac{M}{2^{p-x}}, 0<x\leq p
\end{equation}

Em que M é o maior problema e p é o numero de divisões. Assim a complexidade resultante do tempo do algoritmo é dado por $O(N(x))$. O tempo médio de execução foi da ordem de minutos. E ao mesmo tempo que era registrado o tempo de execução, também eram coletadas amostras de energia a cada segundo, para futuras comparações com o modelo proposto.

Foi utilizado o método busca em grid para encontrar os melhores parâmetros para o modelo. Ele procura entre vários valores especificados os que apresentam melhores resultados. Neste caso, um kernel de função de base radial \abrv[RBF -- Radial Base Funtion]{(RBF)} dado pela Equação $\phi(r)=e^{-(\gamma r)^2}$ com $\gamma=0.5$. A penalidade por termo errado foi $C=10^4$. A implementação utilizada foi a da biblioteca scikit-learn \cite{scikit-learn}. Para treinar o SVR, os dados coletados foram divididos em duas partes, 90 \% para treinamento e 10 \% para teste. O tempo total para coletar os dados da caracterização variou entre algumas horas e 1 dia, dependendo da aplicação.

% \begin{equation}
% \label{eq:rbf}
% \phi(r)=e^{-(\gamma r)^2}
% \end{equation}

O modelo foi validado com uma validação cruzada do tipo fold com 10 divisões, usando MEA e o MEP como métricas.